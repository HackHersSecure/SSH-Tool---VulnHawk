import nmap
import socket
import sys  # Import sys to handle exit
import time  # Import time for adding delays
import datetime

# Report class to gather and save the results
class Report:
    def __init__(self, target_ip, attack_type):
        self.target_ip = target_ip
        self.attack_type = attack_type
        self.date = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.details = []
        self.open_ports = []
        self.banners = []

    def add_detail(self, description):
        self.details.append(description)

    def add_open_port(self, port, proto, service_name):
        self.open_ports.append((port, proto, service_name))

    def add_banner(self, port, banner):
        self.banners.append((port, banner))

    def generate_report(self):
        report_content = f"""
        SSH Exploitation Report
        =======================
        
        Target IP: {self.target_ip}
        Attack Type: {self.attack_type}
        Date: {self.date}
        
        Summary:
        --------
        Open Ports Found: {len(self.open_ports)}
        Banners Collected: {len(self.banners)}
        
        Details:
        --------
        """
        for idx, detail in enumerate(self.details, 1):
            report_content += f"{idx}. {detail}\n"

        if self.open_ports:
            report_content += "\nOpen Ports:\n------------\n"
            for idx, (port, proto, service_name) in enumerate(self.open_ports, 1):
                report_content += f"{idx}. Port {port}/{proto} - Service: {service_name}\n"
        else:
            report_content += "\nNo open ports were found.\n"

        if self.banners:
            report_content += "\nBanners Collected:\n-------------------\n"
            for idx, (port, banner) in enumerate(self.banners, 1):
                report_content += f"{idx}. Port {port} - Banner: {banner}\n"
        else:
            report_content += "\nNo banners were collected.\n"

        report_content += "\nRecommendations:\n-----------------\n"
        report_content += "1. Close unnecessary open ports to reduce attack surface.\n"
        report_content += "2. Regularly update SSH and other services to patch known vulnerabilities.\n"
        report_content += "3. Implement firewall rules to restrict access to SSH services.\n"

        report_content += "\nConclusion:\n-----------\n"
        report_content += "Review the details above and take necessary actions to secure the SSH configuration and prevent unauthorized access.\n"

        return report_content

    def save_report(self):
        # Generate a unique filename with attack type and timestamp
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"vulnhawk_{self.attack_type}_report_{timestamp}.txt"
        report_content = self.generate_report()
        with open(filename, "w") as report_file:
            report_file.write(report_content)
        print(f"[+] Report saved as '{filename}'")

# Function to scan the target host for open SSH ports
def scan_specific_host(host, report):
    scanner = nmap.PortScanner()
    print(f"\n[+] Scanning host: {host}")
    
    try:
        # Scan only the SSH port (22) with verbose output
        scanner.scan(host, '22', '-T4 -v')
        
        # Debugging: print the raw Nmap scan results
        print(f"[DEBUG] Raw Nmap Scan Output: {scanner[host]}")
        report.add_detail(f"Raw Nmap Scan Output: {scanner[host]}")

        if host not in scanner.all_hosts():
            print(f"[!] No scan results for host: {host}. The host might be down or unreachable.")
            report.add_detail(f"No scan results for host: {host}. The host might be down or unreachable.")
            return []

        open_ports = []
        for proto in scanner[host].all_protocols():
            ports = scanner[host][proto].keys()
            for port in ports:
                port_state = scanner[host][proto][port]['state']
                if port_state == 'open':
                    service_name = scanner[host][proto][port]['name']
                    open_ports.append(port)
                    report.add_open_port(port, proto, service_name)
                    print(f"[+] Open port: {port}/{proto} - {service_name}")
        
        return open_ports
    except Exception as e:
        print(f"[!] Error during scan: {e}")
        report.add_detail(f"Error during scan: {e}")
        return []

# Function to perform banner grabbing on open ports to identify services
def banner_grabbing(host, port, report):
    try:
        print(f"\n[+] Attempting banner grab on {host}:{port}")
        s = socket.socket()
        s.connect((host, port))
        s.send(b'Hello\r\n')
        banner = s.recv(1024)
        s.close()
        decoded_banner = banner.decode().strip()
        print(f"[+] Banner: {decoded_banner}")
        report.add_banner(port, decoded_banner)
        return decoded_banner
    except Exception as e:
        print(f"[!] Banner grabbing failed: {e}")
        report.add_detail(f"Banner grabbing failed on port {port}: {e}")
        return None

# Main function to handle the vulnerability scanning process
def main():
    print("Starting Vulnerability Scanner...")
    
    host = input("Enter the target host IP: ")

    # Initialize report with attack type
    report = Report(target_ip=host, attack_type="vulnerability_scan")
    
    # Scan the host for open SSH ports
    open_ports = scan_specific_host(host, report)
    
    if not open_ports:
        print(f"[!] No open ports found on {host} or the host is unreachable.")
        report.add_detail(f"No open ports found on {host} or the host is unreachable.")
        report.save_report()
        return
    
    # Perform banner grabbing on identified open ports
    for port in open_ports:
        banner = banner_grabbing(host, port, report)
        if banner and "SSH" in banner:
            print(f"[+] Possible SSH service detected on {host}:{port}.")
            report.add_detail(f"Possible SSH service detected on {host}:{port}.")
    
    print("\nVulnerability Scanner Completed.")
    
    # Save the report with a unique filename
    report.save_report()

    time.sleep(2)  # Adding delay to observe the output
    end_or_return()  # Call the function to ask the user what to do next

def end_or_return():
    choice = input("\n[1] Return to Main Menu\n[0] Exit\nSelect an option: ")
    if choice == '1':
        from main import main_menu  # Import the main_menu function from main.py
        main_menu()
    elif choice == '0':
        sys.exit()
    else:
        print("[!] Invalid selection.")
        end_or_return()

if __name__ == "__main__":
    main()
